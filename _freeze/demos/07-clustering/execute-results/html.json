{
  "hash": "a087a8e3ff06f9ae629064ca52081516",
  "result": {
    "markdown": "---\ntitle: \"Demo 07: More MDS and Creating Dendrograms\"\nformat: html\n---\n\n\n**The graphs below don't have proper titles, axis labels, legends, etc.  Please take care to do this on your own graphs.**\n\n## MDS meets MCU\n\nWe will work with a dataset about the performance of MCU movies. The dataset was accessed from [here](https://informationisbeautiful.net/visualizations/which-is-the-best-performing-marvel-movie/) with information such as the box office performance and reviews.\n\nHere is the code to read in the data into `R`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nmcu_movies <- read_csv(\"https://raw.githubusercontent.com/ryurko/DataViz-Class-Data/main/mcu_movies.csv\")\n```\n:::\n\n\nFor this demo, we'll focus just on the columns that contain quantitative variables about the movies' performance, but we'll also exclude the `year` variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select only the continuous variables excluding the year\nmcu_quant <- mcu_movies |> \n  dplyr::select(-c(film, category, year))\n```\n:::\n\n\nThere are 15 measurements about each movie:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(mcu_quant)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 15\n  worldwide_gross_m percent_budget_recovered critics_percent_score\n              <dbl>                    <dbl>                 <dbl>\n1               518                      398                    83\n2               623                      479                    87\n3              1395                      382                    76\n4              2797                      699                    94\n5              2048                      683                    85\n6              1336                      668                    96\n# ℹ 12 more variables: audience_percent_score <dbl>,\n#   audience_vs_critics_percent_deviance <dbl>, budget <dbl>,\n#   domestic_gross_m <dbl>, international_gross_m <dbl>,\n#   opening_weekend_m <dbl>, second_weekend_m <dbl>,\n#   x1st_vs_2nd_weekend_drop_off <dbl>,\n#   percent_gross_from_opening_weekend <dbl>,\n#   percent_gross_from_domestic <dbl>, …\n```\n:::\n:::\n\n\nWe're interested in the questions: which of these movies are most similar, and which are most different?\n\nWe're going to follow our workflow from the previous demo and first compute the __distance matrix__ for the movies (based on Euclidean distance), followed by performing multi-dimensional scaling (MDS) to see which movies are \"close\" and which are \"far apart\". \n\nFirst, __scale the data__ and then compute the distance matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This is just one way to scale the data - without centering the columns\nmcu_quant <- apply(mcu_quant, MARGIN = 2,\n                   FUN = function(x) x / sd(x))\nmcu_dist <- dist(mcu_quant)\n```\n:::\n\n\nStaring at a distance matrix and trying to find the most/least similar pairs of observations is not practical for large datasets. This is why an approach like MDS can be really useful: We can quickly see which movies are \"close\" and which are \"far apart\" by plotting the first two coordinates (using `k = 2`). In the code chunk below, we run MDS to get the two new coordinates, then add these coordinates as columns to the original dataset for plotting purposes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Run MDS\nmcu_mds <- cmdscale(d = dist(mcu_quant), k = 2)\n\n# Add to original dataset\nmcu_movies <- mcu_movies |>\n  mutate(mds1 = mcu_mds[,1], \n         mds2 = mcu_mds[,2])\n\n# Create plot:\nmcu_movies |>\n  ggplot(aes(x = mds1, y = mds2)) +\n  geom_point(alpha = .5) +\n  labs(x = \"MDS Coordinate 1\", y = \"MDS Coordinate 2\") +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](07-clustering_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nSince this dataset is relatively small, I can instead plot the film titles directly using `geom_text()` where I just need to map the `film` variable to the `label` aesthetic of the plot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcu_movies |>\n  ggplot(aes(x = mds1, y = mds2)) +\n  # Use text labels instead of points:\n  geom_text(aes(label = film),\n            alpha = .75) +\n  labs(x = \"MDS Coordinate 1\", y = \"MDS Coordinate 2\") +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](07-clustering_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nNow I can see where the movies fall in this projection. If you know anything about the MCU, you can see that some of the biggest movies are along the right-hand side: Black Panther, The Avengers, Spider-Man: No Way Home, Avengers: Infinity War, and Avengers Endgame. We see the various other movies throughout, including the definitive worst MCU movie on the bottom-left corner, as well as a compact group of several movies together. \n\n## Visualizing distance structure with hierarchical clustering and dendrograms\n\nWhile this MDS plot is useful for visualizing how the movies relate to each other. However, it can be difficult to imagine how we could use the MDS plot to identify __clusters__ of movies (unless the points themselves were already clearly clustered, which they are not in the above plot). This is where __dendrograms__ can be a great visual tool for understanding the clustering of observations in your dataset.\n\nDendrograms are tree-like structures used for visualizing distances. Dendrograms have the following axes:\n\n+ y-axis:  distance (or more generally speaking: __dissimilarity__) at which a pair of observations are linked\n\n+ x-axis:  rough grouping of observations (the exact ordering is not necessarily meaningful, other than the fact that pairs of observations near each other are being assigned to the same cluster)\n\nBelow, we implement __hierarchical clustering__ with __complete linkage__ and __single linkage__ (complete linkage is more commonly used), and then plot the results on a dendrogram. We use the `hclust` function in `R` to perform hierarchical clustering (the default `method` is `complete` linkage) given a distance matrix (or in more general terms, a _dissimilarity matrix_). \n\nI'll first start with __complete linkage__:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhc_complete <- hclust(mcu_dist, method = \"complete\")\n\nplot(hc_complete, ylab = \"Pairwise Distance\", \n     main = \"Complete Linkage\", xlab = \"MCU Movies\")\n```\n\n::: {.cell-output-display}\n![](07-clustering_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\nFrom looking at this dendrogram, we can broadly see a group of movies on the right-hand side that are separate from most of the other movies. However, the movies are labeled by their row numbers which is useless for us! We can update the __leaf labels__ by modifying the `labels` input for the `hclust` plot object. For example, I can instead label the movies with the actual film titles:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(hc_complete, ylab = \"Pairwise Distance\", \n     labels = mcu_movies$film,\n     main = \"Complete Linkage\", xlab = \"MCU Movies\")\n```\n\n::: {.cell-output-display}\n![](07-clustering_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nThis is much more useful! I can now see that the group of movies on the right-hand side correspond to the biggest one I previously mentioned, as well as Captain Marvel. From this figure, we can now see which pairs of movies were most similar such as Ant-Man and its sequel, along with Thor and its first sequel (both of which are not great...). \n\n__NOTE:__ This is a small enough dataset that labeling the leaves is worthwhile, but for larger datasets the labels can become problematic and unreadable. Instead, you can also __turn off the leaf labels__ by just setting `label` to `FALSE`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(hc_complete, ylab = \"Pairwise Distance\", \n     labels = FALSE,\n     main = \"Complete Linkage\", xlab = \"MCU Movies\")\n```\n\n::: {.cell-output-display}\n![](07-clustering_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nWhile the above was with complete linkage, the following demonstrates the results with __single linkage__:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhc_single <- hclust(mcu_dist, method = \"single\")\nplot(hc_single, ylab = \"Pairwise Distance\",\n     labels = mcu_movies$film,\n     main = \"Single Linkage\", xlab = \"MCU Movies\")\n```\n\n::: {.cell-output-display}\n![](07-clustering_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nIn this case, we can clearly see a very different looking dendrogram driven by the difference in how we compute distances between clusters. __Single linkage__ results in this _chaining_ effect: where poorly separate but distinct clusters are merged together.\n\nAlternatively, because base `R` plotting is pretty annoying at times, we can instead use the [`ggdendro` package](https://cran.r-project.org/web/packages/ggdendro/vignettes/ggdendro.html) to create our dendrogram. This offers more customization and even allows you to extract a dataset constructed by the dendrogram for use - but we won't focus on that for this demo. Instead the following code uses the `ggdendro` package to create two dendrograms and then plots them side-by-side using the [`patchwork` package](https://patchwork.data-imaginist.com/) (which I have previously used in various solutions):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# You'll need to run the following lines if you do NOT have ggdendro and patchwork \n# packages installed already:\n# install.packages(\"ggdendro\")\n# install.packages(\"patchwork\")\nlibrary(ggdendro)\nlibrary(patchwork)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'patchwork' was built under R version 4.2.3\n```\n:::\n\n```{.r .cell-code}\nhc_single_ggdendro <- ggdendrogram(hc_single, theme_dendro = FALSE) +\n  labs(y = \"Pairwise Distance\", title = \"Single Linkage\") + \n  theme_bw() +\n  # Remove the x-axis title\n  theme(axis.title.x = element_blank())\n\nhc_complete_ggdendro <- ggdendrogram(hc_complete, theme_dendro = FALSE) +\n  labs(y = \"Pairwise Distance\", title = \"Complete Linkage\") + \n  theme_bw() +\n  # Remove the x-axis title\n  theme(axis.title.x = element_blank())\n\nhc_single_ggdendro + hc_complete_ggdendro\n```\n\n::: {.cell-output-display}\n![](07-clustering_files/figure-html/unnamed-chunk-11-1.png){width=768}\n:::\n:::\n\n\nIf we want to add the movie titles to the `ggdendro` version of the dendrogram, we unfortunately we need to go back to the beginning of this process! We need to add `rownames` to our initial dataset that we used for computing the distance matrix. These names will then automatically carry over and serve as the observation labels in the dendrograms above:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add the film titles as the row names for mcu_quant\nrownames(mcu_quant) <- mcu_movies$film\n# Recompute the distance matrix\nmcu_dist <- dist(mcu_quant)\n\n# And repeat the dendrogram process\nhc_complete <- hclust(mcu_dist, method = \"complete\")\nggdendrogram(hc_complete, theme_dendro = FALSE) +\n  labs(y = \"Pairwise Distance\", title = \"Complete Linkage\") + \n  theme_bw() +\n  # Remove the x-axis title\n  theme(axis.title.x = element_blank())\n```\n\n::: {.cell-output-display}\n![](07-clustering_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nBut now we can't read any of the labels! Conveniently, since `ggdendro` returns a `ggplot` object, we can just use `coord_flip()` to make this easier to read:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhc_complete_ggdendro <- ggdendrogram(hc_complete, theme_dendro = FALSE) +\n  labs(y = \"Cluster Dissimilarity (based on complete linkage)\", \n       title = \"Which MCU movies are similar to each other?\") + \n  coord_flip() +\n  theme_bw() +\n  # Remove the y-axis title (changed from x to y since we flipped it!)\n  theme(axis.title.y = element_blank())\n\n# Display this:\nhc_complete_ggdendro\n```\n\n::: {.cell-output-display}\n![](07-clustering_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\nIt can also be helpful to put an MDS plot and a dendrogram plot side-by-side (again using `patchwork`). The MDS plot gives us a better idea of what the dendrogram is doing behind the scenes (think about why).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcu_mds_plot <- mcu_movies |>\n  ggplot(aes(x = mds1, y = mds2)) +\n  geom_text(aes(label = film),\n            alpha = .75) +\n  labs(x = \"MDS Coordinate 1\", y = \"MDS Coordinate 2\") +\n  theme_bw()\n\nmcu_mds_plot + hc_complete_ggdendro\n```\n\n::: {.cell-output-display}\n![](07-clustering_files/figure-html/unnamed-chunk-14-1.png){width=960}\n:::\n:::\n\n\nUsing our dendrogram, we can assign MCU movies to clusters by __cutting the tree__ via the `cutree` function. In terms of code, there are two ways to do this: (1) we pick the height of the tree to cut at or (2) we tell it how many clusters we want and it finds the corresponding height to use. \n\nLet's start with cutting based on the height. From looking at the dendrogram above, I decide to break the movies into clusters based on a threshold of 10, i.e., if the complete linkage distance is $\\leq 10$ then the clusters are merged together while anything above that threshold is in a different cluster.\n\nIf I call this `cutree` function at height `h = 10` , you'll see how it returns arbitrary labels to each movie:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcu_clusters <- cutree(hc_complete, h = 10)\nmcu_clusters\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                          Ant-Man                Ant-Man & The Wasp \n                                1                                 1 \n          Avengers: Age of Ultron                Avengers: End Game \n                                1                                 2 \n           Avengers: Infinity War                     Black Panther \n                                2                                 2 \n                  Black Panther 2                       Black Widow \n                                1                                 1 \n                  Captain America        Captain America: Civil War \n                                1                                 1 \n  Captain America: Winter Soldier                    Captain Marvel \n                                1                                 2 \n                       Dr Strange Dr Strange: Multiverse of Madness \n                                1                                 1 \n                         Eternals           Guardians of the Galaxy \n                                1                                 1 \n        Guardians of the Galaxy 2                   Incredible Hulk \n                                1                                 1 \n                         Iron Man                        Iron Man 2 \n                                1                                 1 \n                       Iron Man 3                         Shang-Chi \n                                1                                 1 \n        Spider-Man: Far from Home            Spider-Man: Homecoming \n                                1                                 1 \n          Spider-Man: No Way Home                      The Avengers \n                                2                                 2 \n                 Thor: Dark World              Thor: Love & Thunder \n                                1                                 1 \n                   Thor: Ragnarok                              Thor \n                                1                                 1 \n```\n:::\n:::\n\n\nThis returns a vector of cluster assignments for every movie (where the names of the vector are the film titles). __NOTE__: The numbers are arbitrary labels without meaninful order! You could replace all the 1s with Zs and all of the 2s with As, and the meaning would be the same. All that matters is which observations have the same labels. I can now add these labels to be another column for my plot above to display what the clusters are via color while denoting the height at which I cut the dendrogram:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncluster_mcu_mds_plot <- mcu_movies |>\n  mutate(cluster = as.factor(mcu_clusters)) |>\n  ggplot(aes(x = mds1, y = mds2,\n             color = cluster)) +\n  geom_text(aes(label = film),\n            alpha = .75) +\n  labs(x = \"MDS Coordinate 1\", y = \"MDS Coordinate 2\") +\n  theme_bw() +\n  theme(legend.position = \"bottom\")\n\n# Update dendogram with cut:\ncut_dendro <- hc_complete_ggdendro +\n  # This is a horizontal line since its considered before the flip:\n  geom_hline(yintercept = 10, linetype = \"dashed\", \n             color = \"darkred\")\n\ncluster_mcu_mds_plot + cut_dendro\n```\n\n::: {.cell-output-display}\n![](07-clustering_files/figure-html/unnamed-chunk-16-1.png){width=960}\n:::\n:::\n\n\n## Other dendrogram visualization tools\n\n### `dendextend`\n\nWe'll learn how to make prettier versions of this in a later lab. In particular, we'll use the [`dendextend`](https://cran.r-project.org/web/packages/dendextend/vignettes/dendextend.html) package (which you'll have to install). This allows you to prespecify $k$ the clusters displayed via color that you want to add to your dendrogram:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Install dendextend if you do not have it already!\n# install.packages(\"dendextend\")\nlibrary(dendextend)\nhc_dendrogram <- as.dendrogram(hc_complete)\nhc_dendrogram <- set(hc_dendrogram,\n                     \"branches_k_color\", k = 4)\nplot(hc_dendrogram, ylab = \"Pairwise Distance\")\n```\n\n::: {.cell-output-display}\n![](07-clustering_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n[Check this page out](http://www.sthda.com/english/wiki/beautiful-dendrogram-visualizations-in-r-5-must-known-methods-unsupervised-machine-learning) for a simple tutorial of customizing dendrograms in `R` using `ggdendro` and `dendextend`.\n\n\n### `factoextra`\n\nAnother package with dendrogram visualizations, that we'll use later on for PCA, is the [`factoextra` package](https://rpkgs.datanovia.com/factoextra/index.html). This package contains many extremely useful functions for creating visualizations without too many steps. We can use the [`fviz_dend()`](https://rpkgs.datanovia.com/factoextra/reference/fviz_dend.html) function to display the dendrogram for an `hclust` object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Install factoextra if you do not have it already!\nlibrary(factoextra)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWelcome! Want to learn more? See two factoextra-related books at https://goo.gl/ve3WBa\n```\n:::\n\n```{.r .cell-code}\nfviz_dend(hc_complete)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The `<scale>` argument of `guides()` cannot be `FALSE`. Use \"none\" instead as\nof ggplot2 3.3.4.\nℹ The deprecated feature was likely used in the factoextra package.\n  Please report the issue at <https://github.com/kassambara/factoextra/issues>.\n```\n:::\n\n::: {.cell-output-display}\n![](07-clustering_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\nWe can customize this in pretty easy ways, such as changing the font size via the `cex` argument and displaying clusters via color:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfviz_dend(hc_complete, cex = 0.25, k = 3, color_labels_by_k = TRUE) \n```\n\n::: {.cell-output-display}\n![](07-clustering_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\nCheck out the function documentation for more customization options: https://rpkgs.datanovia.com/factoextra/reference/fviz_dend.html\n",
    "supporting": [
      "07-clustering_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}