{
  "hash": "c3eae64f91ea1aa3dbf322ed3fcb660d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Demo 12: Visualizations and inference for spatial data\"\nformat: html\n---\n\n\n\n\n# Create a Stadia Maps account\n\nBefore moving on to the code below, you'll first need to create a free Stadia Maps account in order to access the map styles to use with `ggmap`. You can find the directions about the process [here](https://docs.stadiamaps.com/guides/migrating-from-stamen-map-tiles/#ggmap). After you click on the \"Create an Account\" button, follow the steps by entering in your relevant information. Then select Mobile/Native App version to generate an API key. You'll then find your API key in the displayed Stadia-hosted URLs, displayed at the end of the URLs after `api_key=`. Once you have the API key saved somewhere, after you install the `ggmap` package you can then run the following code to save your API key once and then never have to run this step again:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# You first need to install the ggmap R package\n# install.packages(\"ggmap\")\nggmap:register_stadiamaps(\"YOUR-API-KEY-HERE\",\n                          # write = TRUE saves this once\n                          write = TRUE)\n```\n:::\n\n\n\n\n# Creating Maps with `ggmap`\n\nWe can create maps (maps of different type such as \"terrain\", \"stamen_toner_lite\", etc.) with the `ggmap` package, as shown below. Making a basic map with `ggmap` follows three main steps:\n\n+ Specify the coordinates of the \"box\" that you'll draw your map in. This corresponds to the `left`, `bottom`, `right`, and `top` coordinates. The `left` and `right` coordinates are longitude coordinates; the `bottom` and `top` coordinates are latitude coordinates.\n\n+ Put the \"box\" you specified into `get_stadiamap()`. Also within `get_stadiamap()`, specify the `maptype`, which determines the \"terrain\" that is displayed on the map, as well as `zoom`, which determines how much \"local detail\" is displayed on the map. \n\n+ Draw the map using `ggmap()`.\n\nAs an example, the following code draws a map of Pittsburgh. To do this, I first found the latitude/longitude coordinates of center of Pittsburgh. Then, I draw a \"box\" around Pittsburgh by adding and subtracting two latitude/longitude from the central coordinates. Finally, I used `get_stadiamap()` and `ggmap()` to plot the map.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(ggmap)\n\n# step 1: draw the box\npitt <- c(left = -79.9959 - 2, bottom = 40.4406 - 2,\n          right = -79.9959 + 2, top = 40.4406 + 2)\n\n# step 2: use get_stadiamap to specify maptype/zoom\nmap_base <- get_stadiamap(pitt, maptype = \"stamen_toner_lite\", zoom = 8)\n\n# step 3: draw the map with ggmap\nmap_object <- ggmap(map_base, extent = \"device\", \n                    ylab = \"Latitude\", xlab = \"Longitude\")\nmap_object\n```\n\n::: {.cell-output-display}\n![](12-spatial-data_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\n\n## Example: Plotting Airline Flight Data across the US\n\nHere, we'll work with airline data from [this GitHub repository](https://github.com/jpatokal/openflights). You can find out more about this dataset [here](https://openflights.org/data.html).\n\nBefore we begin, note that this is just one example of how you can add interesting information to maps with `ggmap`.  As long as you have latitude and longitude information, you should be able to add data to maps.  For more interesting examples and for an in-depth description of `ggmap`, see the short paper by David Kahle and Hadley Wickham [here](http://stat405.had.co.nz/ggmap.pdf). (This paper may be helpful for teams that will be working with spatial data for the group project.)\n\n## Load flight data from GitHub\n\nHere we will use a large dataset on GitHub about airline flights across the world. After loading in the raw data, we'll do some data manipulation to create useful variables for this dataset.\n\nFirst, we'll load a dataset on airports across the world:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#  Load and format airports data\nairports <- read_csv(\"https://raw.githubusercontent.com/jpatokal/openflights/master/data/airports.dat\",\n                     col_names = c(\"ID\", \"name\", \"city\", \"country\", \"IATA_FAA\", \n                                   \"ICAO\", \"lat\", \"lon\", \"altitude\", \"timezone\", \"DST\"))\n# Here's what the data look like:\nairports\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7,698 × 14\n      ID name   city  country IATA_FAA ICAO    lat   lon altitude timezone DST  \n   <dbl> <chr>  <chr> <chr>   <chr>    <chr> <dbl> <dbl>    <dbl> <chr>    <chr>\n 1     1 Gorok… Goro… Papua … GKA      AYGA  -6.08 145.      5282 10       U    \n 2     2 Madan… Mada… Papua … MAG      AYMD  -5.21 146.        20 10       U    \n 3     3 Mount… Moun… Papua … HGU      AYMH  -5.83 144.      5388 10       U    \n 4     4 Nadza… Nadz… Papua … LAE      AYNZ  -6.57 147.       239 10       U    \n 5     5 Port … Port… Papua … POM      AYPY  -9.44 147.       146 10       U    \n 6     6 Wewak… Wewak Papua … WWK      AYWK  -3.58 144.        19 10       U    \n 7     7 Narsa… Nars… Greenl… UAK      BGBW  61.2  -45.4      112 -3       E    \n 8     8 Godth… Godt… Greenl… GOH      BGGH  64.2  -51.7      283 -3       E    \n 9     9 Kange… Sond… Greenl… SFJ      BGSF  67.0  -50.7      165 -3       E    \n10    10 Thule… Thule Greenl… THU      BGTL  76.5  -68.7      251 -4       E    \n# ℹ 7,688 more rows\n# ℹ 3 more variables: X12 <chr>, X13 <chr>, X14 <chr>\n```\n\n\n:::\n:::\n\n\n\n\nThen, we'll load a dataset on airline flight routes across the world:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#  Load and format routes data\nroutes <- read_csv(\"https://raw.githubusercontent.com/jpatokal/openflights/master/data/routes.dat\",\n                   col_names = c(\"airline\", \"airlineID\", \"sourceAirport\", \n                                 \"sourceAirportID\", \"destinationAirport\", \n                                 \"destinationAirportID\", \"codeshare\", \"stops\",\n                                 \"equipment\"))\n# Here's what the data look like:\nroutes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 67,663 × 9\n   airline airlineID sourceAirport sourceAirportID destinationAirport\n   <chr>   <chr>     <chr>         <chr>           <chr>             \n 1 2B      410       AER           2965            KZN               \n 2 2B      410       ASF           2966            KZN               \n 3 2B      410       ASF           2966            MRV               \n 4 2B      410       CEK           2968            KZN               \n 5 2B      410       CEK           2968            OVB               \n 6 2B      410       DME           4029            KZN               \n 7 2B      410       DME           4029            NBC               \n 8 2B      410       DME           4029            TGK               \n 9 2B      410       DME           4029            UUA               \n10 2B      410       EGO           6156            KGD               \n# ℹ 67,653 more rows\n# ℹ 4 more variables: destinationAirportID <chr>, codeshare <chr>, stops <dbl>,\n#   equipment <chr>\n```\n\n\n:::\n:::\n\n\n\n\n\n## Manipulating the data to get some custom tibbles\n\nHere, we'll do some data manipulation to obtain the number of arrivals/departures per airport.\n\nThe following code does two tasks that very commonly come up with spatial data:\n\n+ Count the number of events at a particular location.\n\n+ Merge two datasets by a common variable (e.g., an ID or location).\n\nWe've seen instances of the first task before (e.g., counting the number of subjects belonging to a certain group). We haven't done the second task before, but it regularly comes up in spatial data: Often, you'll find multiple datasets that contain different variables about the same spatial location, and you'll want to merge them together. We'll do this using the `left_join()` function within the `dplyr` package that's in the `tidyverse`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#  Manipulate the routes data to create two new tibbles:\n#  one for arrivals, one for departures.  \n\n#  Each counts the number of flights arriving/departing from each airport.\ndepartures <- routes |> \n  group_by(sourceAirportID) |>\n  summarize(n_depart = n()) |>\n  # Convert the ID to integer since it's a character (need to have matching\n  # data types for columns you will join on)\n  mutate(sourceAirportID = as.integer(sourceAirportID))\n\narrivals <- routes |> \n  group_by(destinationAirportID) |> \n  summarize(n_arrive = n()) |> \n  mutate(destinationAirportID = as.integer(destinationAirportID))\n\n# Join both of these summaries to the airports data bsed on the ID column to\n# match their respective ID columns\n\n# First join the departures:\nairports <- airports |>\n  # We join the departures so that ID matches sourceAirportID\n  left_join(departures, by = c(\"ID\" = \"sourceAirportID\"))\n\n# And now join arrivals:\nairports <- airports |>\n  # Same process - but different ID\n  left_join(arrivals, by = c(\"ID\" = \"destinationAirportID\"))\n```\n:::\n\n\n\n\nThus, each row corresponds to a *single* airport with columns about the airport along with info about the number of flights (departures and arrivals).\n\n## Mapping the data we created\n\nFirst, we'll use `ggmap` to create a base map of the data. Although the dataset is for the whole world, we'll focus on the US for simplicity.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# First, we'll draw a \"box\" around the US\n# (in terms of latitude and longitude)\nUS <- c(left = -125, bottom = 10, right = -67, top = 49)\nmap <- get_stadiamap(US, zoom = 5, maptype = \"stamen_toner_lite\")\n#  Visualize the basic map\nggmap(map)\n```\n\n::: {.cell-output-display}\n![](12-spatial-data_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n\nNow we'll demonstrate how to add points to the map using `geom_point()`. Thus, this is equivalent to creating a scatterplot, but within the space of a map.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#  Add points to the map of airports\nggmap(map) + \n  geom_point(data = airports, aes(x = lon, y = lat), alpha = .25)\n```\n\n::: {.cell-output-display}\n![](12-spatial-data_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n\nWe can also add contour lines using `stat_density2d()`, just like we did with scatterplots. In the code below, we also use the `bins` argument, which we haven't seen before in `stat_density2d`, but intuitively it is the same as when we used `bins` for histograms: More `bins` corresponds to more granularity in the data. I've found that not specifying `bins` can give very odd results for spatial data, so I recommend setting `bins` to a somewhat low value such that you can easily see high- and low-density areas on a map.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggmap(map) +\n  stat_density2d(data = airports,\n                 aes(x = lon, y = lat, fill = after_stat(level)),\n                 alpha = 0.2, geom = \"polygon\", bins = 4) +\n  geom_point(data = airports, aes(x = lon, y = lat), alpha = .25)\n```\n\n::: {.cell-output-display}\n![](12-spatial-data_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n\nNow, think about what the above map is displaying. It is density of *airports* (which correspond to the rows of our dataset), but it is not displaying the density of *flights* (arrivals or departures). How can we display the density of flights on this map?\n\nA common option is to make the size of the points proportional to a third variable (in this case `departures`):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#  Add points to the map of airports\n#  Each point will be located at the lat/long of the airport\n#  The size of the points is proportional to the square root of the number of departures at that airport\nmap_point_depart <- ggmap(map) +\n  geom_point(data = airports, \n             aes(x = lon, y = lat, size = sqrt(n_depart)), alpha = .25)\n\n# In this case, it can be helpful to create your own legend for the plot, so \n# that you can set which sizes of the correspond to which values in the data:\nmap_point_depart <- map_point_depart + \n  scale_size_area(breaks = sqrt(c(1, 5, 10, 50, 100, 500)), \n                  labels = c(1, 5, 10, 50, 100, 500), \n                  name = \"# departures\")\nmap_point_depart\n```\n\n::: {.cell-output-display}\n![](12-spatial-data_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n\nYou could also change the color of the points. **However, as we've seen previously, just setting `color = variable` for a continuous variable often gives unsatisfactory results** (because the default colors aren't great). This is especially true for spatial data, where there is often a wide range of responses across geography.\n\nIn what follows, I demonstrate two ways that you can manually change the colors on a map; one uses `scale_color_gradient2()`, and one uses `scale_color_distiller`. The second one is more straightforward, but the first one allows for more flexibility.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# What happens if we just set sqrt(n_depart) equal to color\nggmap(map) +\n  geom_point(data = airports, \n             aes(x = lon, y = lat, color = sqrt(n_depart)), alpha = .5)\n```\n\n::: {.cell-output-display}\n![](12-spatial-data_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Using scale_color_gradient2 to manually set the color scale\nggmap(map) +\n  geom_point(data = airports, \n             aes(x = lon, y = lat, color = sqrt(n_depart)), alpha = .5) +\n  # Note that you can also set a \"mid\" color, which is what the color will be \n  # at the midpoint (which you also set). Using limits (or breaks, \n  # which I don't do here) is very useful when your variable has a wide range \n  # and/or is very skewed (which is the case for the n_depart variable).\n  scale_color_gradient2(low = \"blue\", mid = \"purple\", high = \"red\", \n                        midpoint = 12.5, limits = sqrt(c(1, 500)))\n```\n\n::: {.cell-output-display}\n![](12-spatial-data_files/figure-html/unnamed-chunk-10-2.png){width=672}\n:::\n\n```{.r .cell-code}\n# Using scale_color_distiller to manually set the color scale\nggmap(map) +\n  geom_point(data = airports, \n             aes(x = lon, y = lat, color = sqrt(n_depart)), alpha = .5) +\n  # Note that there are many different palettes - see help documentation\n  # for scale_color_distiller\n  scale_color_distiller(palette = \"Spectral\") \n```\n\n::: {.cell-output-display}\n![](12-spatial-data_files/figure-html/unnamed-chunk-10-3.png){width=672}\n:::\n:::\n\n\n\n\nWe could of course map one variable to size and another to color, e.g., `n_depart` to size and `n_arrive` to color. You should NOT map one variable to both aesthetics - that is a redundant display of information.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggmap(map) +\n  geom_point(data = airports, \n             aes(x = lon, y = lat, \n                 size = sqrt(n_depart), color = sqrt(n_arrive)), \n             alpha = .5) +\n  scale_size_area(breaks = sqrt(c(1, 5, 10, 50, 100, 500)), \n                  labels = c(1, 5, 10, 50, 100, 500), \n                  name = \"# departures\") +\n  scale_color_distiller(palette = \"Spectral\") +\n  labs(color = \"sqrt(# arrivals)\")\n```\n\n::: {.cell-output-display}\n![](12-spatial-data_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n\nFinally, we can (as usual) change the shape of the points according to another variable. The following marks airports that have an altitude higher than 1500 feet (which I don't think would normally be of scientific interest, but this nonetheless shows you how to change `shape` in this way):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggmap(map) +\n  geom_point(data = airports, \n             aes(x = lon, y = lat, \n                 size = sqrt(n_depart), color = sqrt(n_arrive),\n                 shape = altitude > 1500), \n             alpha = .5) +\n  scale_size_area(breaks = sqrt(c(1, 5, 10, 50, 100, 500)), \n                  labels = c(1, 5, 10, 50, 100, 500), \n                  name = \"# departures\") +\n  scale_color_distiller(palette = \"Spectral\") +\n  labs(color = \"sqrt(# arrivals)\")\n```\n\n::: {.cell-output-display}\n![](12-spatial-data_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\n\nThe above plots are nice ways to show the distribution of the number of flights. However, earlier we used `stat_density2d` to plot the density of airports. How can we use this function to plot the density of flights?\n\nThis requires a bit of hacking. The `stat_density2d` will plot the density of points across *rows* in your dataset. Thus, if we want to look at the density of departures, we can duplicate rows that have multiple departures For example, if an airport has `n_depart = 5`, we can create 5 rows in a new dataset for that airport. Then, we can use `stat_density_2d` on this \"duplicated\" dataset.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# First remove the airports with missing n_depart\nclean_airports <- airports |>\n  filter(!is.na(n_depart)) # ! is the negate operator in R, so this only keeps\n  # rows where n_depart is NOT missing  \n\nairports_duplicated <- clean_airports[rep(row.names(clean_airports), \n                                          clean_airports$n_depart),]\n\nggmap(map) + stat_density2d(data = airports_duplicated,\n                            aes(x = lon, y = lat, fill = after_stat(level)), \n                                alpha = 0.2, geom = \"polygon\")\n```\n\n::: {.cell-output-display}\n![](12-spatial-data_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n\nUnsurprisingly, we see there are higher concentrations of flights at major cities. Arguably, it's much easier to deduce this from the above density plot than from the color plots. But both types of plots (density plots and color plots) serve a purpose, and preference for one or the other will depend on the application and the questions of interest.\n\n# Facetting Maps\n\nIn the above, we demonstrated how you can change the `shape` of points to see high- and low-altitude airports. We can also use facetting to compare high- and low-altitude airports.\n\nFacetting with maps is exactly the same as facetting with other graphs; we just use the  `facet_wrap()` or `facet_grid()` functions. There is one added bonus when facetting with graphs: In the plot below, not only do we get to compare the distribution of departure and arrivals for high- and low-altitude airports, but also we can more easily see where high- and low-altitude airports are within the US.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggmap(map) +\n  geom_point(data = airports, \n             aes(x = lon, y = lat, \n                 size = sqrt(n_depart), color = sqrt(n_arrive)), \n             alpha = .5) +\n  scale_size_area(breaks = sqrt(c(1, 5, 10, 50, 100, 500)), \n                  labels = c(1, 5, 10, 50, 100, 500), \n                  name = \"# departures\") +\n  scale_color_distiller(palette = \"Spectral\") +\n  labs(color = \"sqrt(# arrivals)\") +\n  facet_wrap(~ altitude > 1500)\n```\n\n::: {.cell-output-display}\n![](12-spatial-data_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n\n# Statistical Analyses for Point-Reference Data\n\nIt can be helpful complement graphs like the oned above with statistical models for predicting the number of `sqrt(n_depart)` on top of our map. There is a huge literature on how to model spatial outcomes, and we are only going to consider two simple examples in this class that we've learned before: linear regression and `loess`.\n\nFirst, we can consider running a linear regression on our data. To perform statistical analyses on the data displayed in the map, we must first \"grab\" the subset of the data that is being displayed in the map:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nairports_subset <- airports |>\n  filter(lat >= 10 & lat <= 49 & lon >= -125 & lon <= -67)\n```\n:::\n\n\n\n\nThen, we can run a linear regression between our outcome `sqrt(n_depart)` and latitude and longitude:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(lm(sqrt(n_depart) ~ lat + lon, data = airports_subset))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = sqrt(n_depart) ~ lat + lon, data = airports_subset)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-3.0399 -2.1437 -1.2636  0.3869 26.6195 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  4.97196    1.03451   4.806 1.98e-06 ***\nlat         -0.01076    0.01635  -0.658    0.511    \nlon          0.01161    0.01072   1.083    0.279    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 3.77 on 561 degrees of freedom\n  (1106 observations deleted due to missingness)\nMultiple R-squared:  0.003578,\tAdjusted R-squared:  2.538e-05 \nF-statistic: 1.007 on 2 and 561 DF,  p-value: 0.3659\n```\n\n\n:::\n:::\n\n\n\n\nThink about why it's unsurprising that neither of these terms are significant (but for different reasons). It'll be helpful to refer back to the map above.\n\nTo address this, it can sometimes be helpful to run multiple models on different subsets of the data. For example, we can divide the data into the eastern and western parts of the US:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The following code divides the data into the eastern and western\n# parts of the US (I Googled \"middle of united states longitude\")\nairports_west <- airports_subset |> filter(lon <= -98.5795)\nairports_east <- airports_subset |> filter(lon > -98.5795)\n\n# Now let's perform a linear regression:\nsummary(lm(sqrt(n_depart) ~ lat + lon, data = airports_west))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = sqrt(n_depart) ~ lat + lon, data = airports_west)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-3.3979 -1.8717 -0.8102  0.3643 17.9495 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)   \n(Intercept) -3.93970    3.78550  -1.041  0.29947   \nlat         -0.11022    0.03430  -3.214  0.00157 **\nlon         -0.10060    0.03765  -2.672  0.00827 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 3.408 on 171 degrees of freedom\n  (314 observations deleted due to missingness)\nMultiple R-squared:  0.0666,\tAdjusted R-squared:  0.05568 \nF-statistic: 6.101 on 2 and 171 DF,  p-value: 0.002759\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(lm(sqrt(n_depart) ~ lat + lon, data = airports_east))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = sqrt(n_depart) ~ lat + lon, data = airports_east)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-2.9834 -2.2450 -1.4504  0.5261 26.5616 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)  \n(Intercept)  4.62321    2.00581   2.305   0.0217 *\nlat          0.00685    0.01896   0.361   0.7182  \nlon          0.01381    0.02330   0.593   0.5537  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 3.882 on 387 degrees of freedom\n  (792 observations deleted due to missingness)\nMultiple R-squared:  0.001166,\tAdjusted R-squared:  -0.003996 \nF-statistic: 0.2259 on 2 and 387 DF,  p-value: 0.7979\n```\n\n\n:::\n:::\n\n\n\n\nCompare and contrast these regressions with each other as well as with the \"overall\" regression we did earlier.\n\nNow let's consider using `loess`. As a reminder, we learned how to plot loess curves when we have one quantitative covariate and one quantitative outcome. For example, the below plot makes a scatterplot of longitude and `sqrt(n_depart)` with a loess curve on top.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nairports_subset |>\n  ggplot(aes(x = lon, y = sqrt(n_depart))) +\n  geom_point(alpha = 0.5) + \n  geom_smooth(method = \"loess\")\n```\n\n::: {.cell-output-display}\n![](12-spatial-data_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\n\nYou can interpret the above plot as what we would estimate `sqrt(n_depart)` to be when we move from west to east (left to right), averaged across all latitude values. What's nice about `loess` is that it's a very easy way to fit a flexible regression line. How can we make something similar to the above, but accounting for longitude *and* latitude in our `loess` curve? It takes more work than just one line of code to answer this question, but the pay-off is usually worth it (i.e., you'll get a cool/informative graph).\n\nLet's consider a `loess` model that includes latitude and longitude. The following model includes the main effects for latitude and longitude as well as their interaction, making for a (relatively) flexible model: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloess_model <- loess(sqrt(n_depart) ~ lon * lat, data = airports_subset,\n                     control = loess.control(surface = \"direct\"))\n```\n:::\n\n\n\n\nThe line `control = loess.control(surface = \"direct\")` (which we have not seen before) basically says, \"`loess`, please extrapolate when making predictions from this model.\" Usually it's not a good idea to extrapolate, but also with map data it's usually clear where extrapolations occur, as we will see shortly.\n\nNow we have built a \"flexible\" model for the outcome using `loess`. A natural question to ask is: Based on the data, what does `loess` estimate the number of flights is across different areas of the country? To answer this question, we will follow this workflow:\n\n+ Make a point-referenced map of the outcome variable (as we have done above).\n\n+ In code (not visually), make a grid of latitude and longitude points on your map.\n\n+ Using your `loess` model, predict what the outcome variable is at each point on the grid.\n\n+ Add the predictions in the third bulletpoint to the point-referenced map in the first bulletpoint using contour lines.\n\nBelow is the code to implement this workflow for the airline example. We already completed the first bulletpoint, so now we just need to do the last three bulletpoints (below).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Now we'll predict what the sqrt(n_depart) is for a grid of lat/long points.\n# This code creates a sequence of latitude and longitude points where\n# we want to predict/estimate what sqrt(n_depart) is:\nlat_grid <- seq(10, 49, by = 1)\nlon_grid <- seq(-125, -67, by = 2)\n\n# the following line creates a grid of the lat and long coordinates\n# (To better understand what this line is doing, it'd be helpful to\n# look at the help documentation for expand.grid, which is often used\n# in computational statistics. Note we named the columns to match the \n# ones used for the model.)\nlonlat_grid <- expand.grid(\"lon\" = lon_grid, \n                           \"lat\" = lat_grid,\n                           # NOTE: We use the following input when using a \n                           # grid input for the loess model - this ensures\n                           # that the predictions we get will be returned in \n                           # a long column versus a grid (see what happens when\n                           # you comment out the following line for yourself)\n                           KEEP.OUT.ATTRS = FALSE)\n\n# predicted values of sqrt(n_depart) along the grid\nloess_pred <- predict(loess_model, lonlat_grid)\n\n# Now we need to attach these predicted values to the grid of points that we created earlier:\nloess_pred_tbl <- lonlat_grid |>\n  # Convert to tibble:\n  as_tibble() |>\n  # Add this column:\n  mutate(pred_n_depart = loess_pred)\n\n# Now we'll make the scatterplot map again, but with contours for what loess predicts on top:\nggmap(map) +\n  geom_point(data = airports, \n             aes(x = lon, y = lat, size = sqrt(n_depart)), \n             alpha = .5) +\n  geom_contour_filled(data = loess_pred_tbl, binwidth = 1,\n                      aes(x = lon, y = lat, z = loess_pred, \n                          color = after_stat(level)),\n                      alpha = 0.2) +\n  scale_size_area(breaks = sqrt(c(1, 5, 10, 50, 100, 500)), \n                  labels = c(expression(sqrt(1)), expression(sqrt(5)), \n                             expression(sqrt(10)), expression(sqrt(50)),\n                             expression(sqrt(100)), expression(sqrt(500)))) +\n  labs(size = \"sqrt(# departures)\", \n       color = \"level\", fill = \"level\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 7134 rows containing missing values or values outside the scale range\n(`geom_point()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](12-spatial-data_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\n\nThere are several takeaways from this plot. First, we can see that - unsurprisingly - `loess` is detecting that higher numbers of flights are occurring in the eastern and western parts of the US. Sure, we already knew this from the previous plot, but now we have a statistical model that verifies that finding. Furthermore, we can see the estimated number of flights is only low for the very northern part of the US and South America, which probably also aligns with your intuition. Finally, the model is suggesting something that definitely should *not* align with your intuition: It is estimating that there is a high number of flights in the middle of the Pacific Ocean!! However, there is no data out in the Pacific Ocean, so we know that the model is extrapolating outside the range of our data and that we should take these results with a very large grain of salt (i.e., probably not trust it). In this example, `loess` is probably making the following logic: \"Let's say I start in Nevada and go a little bit west - the number of flights goes up a lot! So, if I keep going west, the number of flights will probably keep going up?\" That logic ends up being __incorrect__, and thus results in untrustworthy/unintuitive __extrapolations.__\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}