{
  "hash": "bd51c2531508cdfdb25585120f31cbba",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Demo 06: Visualizing Distances for High-Dimensional Data\"\nformat: html\n---\n\n\n\n\n**The graphs below don't have proper titles, axis labels, legends, etc.  Please take care to do this on your own graphs.**\n\nThroughout this demo we use a dataset about Starbucks drinks available in the [#TidyTuesday project](https://github.com/rfordatascience/tidytuesday/blob/master/data/2021/2021-12-21/readme.md).\n\nYou can read in and manipulate various columns in the dataset with the following code:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nstarbucks <- \n  read_csv(\"https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-12-21/starbucks.csv\") |>\n  # Convert columns to numeric that were saved as character\n  mutate(trans_fat_g = as.numeric(trans_fat_g),\n         fiber_g = as.numeric(fiber_g))\n```\n:::\n\n\n\n\n\n## So far...\n\nWe've been working with \"tidy data\" -- data that has $n$ rows and $p$ columns, where each row is an observation, and each column is a variable describing some feature of each observation.  \n\nNow we'll discuss more complicated data structures.\n\n## Distance matrices\n\nA distance matrix is a data structure that specifies the \"distance\" between each pair of observations in the original $n$-row, $p$-column dataset.  For each pair of observations (e.g. $x_i, x_j$) in the original dataset, we compute the distance between those observations, denoted as $d(x_i, x_j)$ or $d_{ij}$ for short.\n\nA variety of approaches for calculating the distance between a pair of observations can be used. The most commonly used approach (when we have quantitative variables) is called \"Euclidean Distance\".  The Euclidean distance between observations $x_i$ and $x_j$ is defined as follows:  $d(x_i, x_j) = \\sqrt{\\sum_{l = 1}^p (x_{i,l} - x_{j,l}) ^ 2}$.  That is, it is the square root of the sum of squared differences between each column ($l \\in \\{1, ..., p\\}$) of $x_i$ and $x_j$ (remember, there are $p$ original columns / variables).\n\nNote that if some variables in our dataset have substantially higher variance than others, the high-variance variables will dominate the calculation of distance, skewing our resulting distances towards the differences in these variables. As such, __it's common to scale the original dataset before calculating the distance__, so that each variable is on the same scale.\n\n## Starbucks drinks dataset\n\nIn this `R` demo we will look at Starbucks drinks ([courtesy of the #TidyTuesday project](https://github.com/rfordatascience/tidytuesday/blob/master/data/2021/2021-12-21/readme.md)). In short, this is a dataset containing nutritional information about Starbucks drinks. We're going to consider all of the quantitative variables in this dataset, starting with fifth column `serv_size_m_l` to the final column `caffeine_mg`. You can read about the columns in the dataset [here](https://github.com/rfordatascience/tidytuesday/blob/master/data/2021/2021-12-21/readme.md). After selecting the desired columns, the first thing we're going to do is use the `scale()` function to ensure each variable on the same scale, i.e., variances are equal to 1.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select the variables of interest:\nstarbucks_quant_data <- starbucks |>\n  dplyr::select(serv_size_m_l:caffeine_mg)\n# Now scale each column so that the variance is 1 using the scale function:\n# We specify here to not center the data and need to follow the directions in\n# the help page of scale to ensure we are properly standardizing the variance\nstarbucks_scaled_quant_data <- \n  scale(starbucks_quant_data, center = FALSE, \n        scale = apply(starbucks_quant_data,\n                      2, sd, na.rm = TRUE)) \n\n# Just for reference - this is equivalent to the following commented out code:\n# starbucks_quant_data <- starbucks |>\n#   dplyr::select(serv_size_m_l:caffeine_mg)\n# starbucks_scaled_quant_data <- apply(starbucks_quant_data, MARGIN = 2,\n#                                      FUN = function(x) x / sd(x))\n```\n:::\n\n\n\n\nThe most common way to compute distances in `R` is to use the `dist` function. This takes in a dataset and returns the distance matrix for that dataset. By default this computes the euclidean distance (`method = \"euclidean\"`), but other distance metrics can be used.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate distance matrix.\n# As an example, we'll just look at the first five rows:\ndist(starbucks_scaled_quant_data[1:5,])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         1        2        3        4\n2 1.059790                           \n3 2.160501 1.101588                  \n4 3.388562 2.331643 1.232345         \n5 1.472299 2.380300 3.425819 4.643997\n```\n\n\n:::\n\n```{.r .cell-code}\n# You can also include the diagonal if you want:\n# (the diagonal will always be 0s)\ndist(starbucks_scaled_quant_data[1:5,], diag = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         1        2        3        4        5\n1 0.000000                                    \n2 1.059790 0.000000                           \n3 2.160501 1.101588 0.000000                  \n4 3.388562 2.331643 1.232345 0.000000         \n5 1.472299 2.380300 3.425819 4.643997 0.000000\n```\n\n\n:::\n\n```{.r .cell-code}\n# You can also include the \"upper triangle\" if you want:\ndist(starbucks_scaled_quant_data[1:5,], upper = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         1        2        3        4        5\n1          1.059790 2.160501 3.388562 1.472299\n2 1.059790          1.101588 2.331643 2.380300\n3 2.160501 1.101588          1.232345 3.425819\n4 3.388562 2.331643 1.232345          4.643997\n5 1.472299 2.380300 3.425819 4.643997         \n```\n\n\n:::\n\n```{.r .cell-code}\n# Can also include both:\n# (this is the full distance matrix)\ndist(starbucks_scaled_quant_data[1:5,], diag = T, upper = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         1        2        3        4        5\n1 0.000000 1.059790 2.160501 3.388562 1.472299\n2 1.059790 0.000000 1.101588 2.331643 2.380300\n3 2.160501 1.101588 0.000000 1.232345 3.425819\n4 3.388562 2.331643 1.232345 0.000000 4.643997\n5 1.472299 2.380300 3.425819 4.643997 0.000000\n```\n\n\n:::\n\n```{.r .cell-code}\n# Can also consider other distance metrics\n# The default is euclidean, as you can see below:\n# (compare to what you see above)\ndist(starbucks_scaled_quant_data[1:5,], method = \"euclidean\", diag = T, upper = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         1        2        3        4        5\n1 0.000000 1.059790 2.160501 3.388562 1.472299\n2 1.059790 0.000000 1.101588 2.331643 2.380300\n3 2.160501 1.101588 0.000000 1.232345 3.425819\n4 3.388562 2.331643 1.232345 0.000000 4.643997\n5 1.472299 2.380300 3.425819 4.643997 0.000000\n```\n\n\n:::\n\n```{.r .cell-code}\n# For example, can consider the Manhattan distance:\ndist(starbucks_scaled_quant_data[1:5,], method = \"manhattan\", diag = T, upper = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         1        2        3        4        5\n1 0.000000 1.552865 3.109038 4.818573 1.472299\n2 1.552865 0.000000 1.556173 3.265708 3.025165\n3 3.109038 1.556173 0.000000 1.709535 4.581337\n4 4.818573 3.265708 1.709535 0.000000 6.290872\n5 1.472299 3.025165 4.581337 6.290872 0.000000\n```\n\n\n:::\n:::\n\n\n\n\nFor the purposes of this class, we'll mostly focus on the Euclidean distance, so let's define that here:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist_euc <- dist(starbucks_scaled_quant_data)\n```\n:::\n\n\n\n\n## Implementing multi-dimensional scaling\n\nNow we will implement multi-dimensional scaling (MDS) in `R`. As a reminder, MDS tries to find the \"best\" $k$-dimensional projection of the original $p$-dimensional dataset ($k < p$).  \n\nAs such, MDS tries to preserve the _order_ of the pairwise distances. That is, pairs of observations with low distances in the original $p$-column dataset will still be have low distances in the smaller $k$-column dataset.  Similarly, pairs of observations with high distances in the original $p$-column dataset will still be have high distances in the smaller $k$-column dataset.\n\nMDS can be implemented in `R` using the `cmdscale` function. This function takes a distance matrix (**not a dataset!!**):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstarbucks_mds <- cmdscale(d = dist_euc, k = 2)\n```\n:::\n\n\n\n\nNote that you can change $k$ to be greater than 2 if you want, but usually we want $k = 2$ so that we can plot the (projected) distances in a scatterplot; see below.\n\nFor the purposes of plotting, let's add the two coordinates of `mds` to our original dataset:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstarbucks <- starbucks |>\n  mutate(mds1 = starbucks_mds[,1], mds2 = starbucks_mds[,2])\n```\n:::\n\n\n\n\nThen, we can make a plot with `ggplot`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstarbucks |>\n  ggplot(aes(x = mds1, y = mds2)) +\n  geom_point(alpha = 0.5) +\n  labs(x = \"Coordinate 1\", y = \"Coordinate 2\")\n```\n\n::: {.cell-output-display}\n![](06-mds_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n\nIt can be helpful to add colors and/or shapes of the plot according to categorical variables. For example, here's the plot colored by `size`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstarbucks |>\n  ggplot(aes(x = mds1, y = mds2, color = size)) +\n  geom_point(alpha = 0.5) +\n  labs(x = \"Coordinate 1\", y = \"Coordinate 2\")\n```\n\n::: {.cell-output-display}\n![](06-mds_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n\nTo get some insight into the _contributions_ by the different continous variables, we could also map them to various aesthetics. For example, the following plots displays points colored by `sugar_g`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstarbucks |>\n  ggplot(aes(x = mds1, y = mds2, color = sugar_g)) +\n  geom_point(alpha = 0.5) +\n  scale_color_gradient(low = \"darkblue\", high = \"darkorange\") +\n  labs(x = \"Coordinate 1\", y = \"Coordinate 2\")\n```\n\n::: {.cell-output-display}\n![](06-mds_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n\nWhat do these two colored plots tell us about the data? \n",
    "supporting": [
      "06-mds_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}